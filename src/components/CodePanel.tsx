import { useState, useEffect, useRef, memo } from 'react'
import { flushSync } from 'react-dom'
import Editor from 'react-simple-code-editor'
import { highlight, languages } from 'prismjs'
import 'prismjs/components/prism-python'
import 'prismjs/themes/prism-tomorrow.css'
import { usePyScript } from '../hooks/usePyScript'
import type { CoordinateFrame, Vector, FunctionPlot } from '../types'

interface CodePanelProps {
  selectedFrame: CoordinateFrame | null
  onCodeChange: (frameId: string, code: string) => void
  onCodeRun?: (frameId: string, code: string) => void
  onVectorsUpdate?: (frameId: string, vectors: Vector[], replace?: boolean) => void
  onFunctionsUpdate?: (frameId: string, functions: FunctionPlot[], replace?: boolean) => void
  onVectorsClear?: (frameId: string) => void
  onFunctionsClear?: (frameId: string) => void
  externalExecutionResult?: { success: boolean; error?: string } | null // Execution result from external (auto-execution)
  onExecutionErrorChange?: (hasError: boolean) => void // Callback to notify parent of error state changes
}

// Default code is now generated by codeGenerator.ts
// This fallback is only used if frame.code is empty
const DEFAULT_CODE = `import math
import numpy as np
from scipy import linalg

# Predefined functions available:
# - draw(vector, color?) - Draw a vector from origin
# - plot(formula, x_min, x_max, color?, num_points?) - Plot a function
`

function CodePanel({
  selectedFrame,
  onCodeChange,
  onCodeRun,
  onVectorsUpdate,
  onFunctionsUpdate,
  onVectorsClear,
  onFunctionsClear,
  externalExecutionResult,
  onExecutionErrorChange,
}: CodePanelProps) {
  const [localCode, setLocalCode] = useState<string>('')
  const [isRunning, setIsRunning] = useState(false)
  const [localExecutionResult, setLocalExecutionResult] = useState<{ success: boolean; error?: string } | null>(null)
  const [showLoading, setShowLoading] = useState(false)
  const { isReady, executeCode, isExecuting } = usePyScript()
  
  // Use external result if available, otherwise use local result
  // BUT: if local result is an error, it takes precedence (manual execution errors should always show)
  // This ensures that when user clicks Run and gets an error, it's not hidden by a previous success
  let executionResult: { success: boolean; error?: string } | null = null
  if (localExecutionResult && !localExecutionResult.success) {
    // Manual execution error takes precedence
    executionResult = localExecutionResult
  } else if (externalExecutionResult) {
    // Use external result (from auto-execution)
    executionResult = externalExecutionResult
  } else if (localExecutionResult) {
    // Use local result (manual execution success)
    executionResult = localExecutionResult
  }
  
  // Notify parent of error state changes (for badge indicator)
  // Manual execution results take precedence: if manual execution succeeds, clear the badge
  // even if there's a previous auto-execution error
  useEffect(() => {
    const hasLocalError = !!(localExecutionResult && !localExecutionResult.success)
    const hasLocalSuccess = !!(localExecutionResult && localExecutionResult.success)
    const hasExternalError = !!(externalExecutionResult && !externalExecutionResult.success)
    
    // If manual execution succeeded, always clear the badge (regardless of external errors)
    // Otherwise, show badge if there's any error (local or external)
    const hasAnyError = hasLocalSuccess ? false : (hasLocalError || hasExternalError)
    
    if (onExecutionErrorChange) {
      onExecutionErrorChange(hasAnyError)
    }
  }, [localExecutionResult, externalExecutionResult, onExecutionErrorChange])
  
  const editorRef = useRef<HTMLDivElement>(null)
  const textareaRef = useRef<HTMLTextAreaElement | null>(null)
  const preRef = useRef<HTMLPreElement | null>(null)
  const lineNumbersRef = useRef<HTMLDivElement | null>(null)

  // Track previous frame ID to detect actual frame changes (not just object reference changes)
  const previousFrameIdRef = useRef<string | null>(null)
  
  // Update local code when selected frame changes
  useEffect(() => {
    const currentFrameId = selectedFrame?.id || null
    const previousFrameId = previousFrameIdRef.current
    
    // Only clear execution result if the frame ID actually changed
    if (currentFrameId !== previousFrameId) {
      previousFrameIdRef.current = currentFrameId
      
      if (selectedFrame) {
        // Use frame's code if available, otherwise use default
        setLocalCode(selectedFrame.code || DEFAULT_CODE)
        // Clear local execution result when frame ID changes (both success and error)
        setLocalExecutionResult(null)
      } else {
        setLocalCode('')
        setLocalExecutionResult(null)
      }
    } else if (selectedFrame) {
      // Same frame, just update code if it changed (but don't clear execution result)
      setLocalCode(selectedFrame.code || DEFAULT_CODE)
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedFrame])

  // DO NOT update local code when autoExecuteCode changes
  // autoExecuteCode is only for execution, not for updating the displayed code
  // The displayed code should only come from:
  // 1. The frame's code (when frame changes)
  // 2. User edits (when they type)
  // This prevents overwriting user's code when auto-execution happens

  // Sync scroll between textarea and line numbers
  // Note: react-simple-code-editor handles textarea/pre alignment internally
  // We only need to sync line numbers with textarea
  // IMPORTANT: Don't depend on localCode - preserve scroll position during editing
  useEffect(() => {
    const editorContainer = editorRef.current
    if (!editorContainer) {
      return
    }

    const textarea = editorContainer.querySelector('textarea') as HTMLTextAreaElement
    const pre = editorContainer.querySelector('pre') as HTMLPreElement
    const lineNumbers = lineNumbersRef.current
    
    
    if (!textarea || !pre) {
      return
    }

    textareaRef.current = textarea
    preRef.current = pre

    // Fix pre element height to match textarea exactly
    // This prevents the 10px height difference that causes scroll misalignment
    // Fix pre element height to match textarea exactly
    // IMPORTANT: Preserve scroll position when syncing heights
    const syncHeights = () => {
      if (textarea && pre) {
        // Preserve scroll position before height change
        const savedScrollTop = textarea.scrollTop
        const savedScrollLeft = textarea.scrollLeft
        
        const textareaHeight = textarea.clientHeight
        
        // ALWAYS set the height, even if close, to ensure it matches exactly
        // Use !important to override any CSS that might be interfering
        pre.style.setProperty('height', `${textareaHeight}px`, 'important')
        
        // Force a reflow to ensure the change takes effect
        void pre.offsetHeight
        
        const afterSet = pre.clientHeight
        
        // If still different, try setting max-height as well
        if (Math.abs(afterSet - textareaHeight) > 0.1) {
          pre.style.setProperty('max-height', `${textareaHeight}px`, 'important')
          pre.style.setProperty('min-height', `${textareaHeight}px`, 'important')
          void pre.offsetHeight
        }
        
        // Restore scroll position after height change
        if (textarea.scrollTop !== savedScrollTop || textarea.scrollLeft !== savedScrollLeft) {
          textarea.scrollTop = savedScrollTop
          textarea.scrollLeft = savedScrollLeft
        }
      }
    }
    
    // Sync heights immediately and on resize
    syncHeights()
    const resizeObserver = new ResizeObserver(() => {
      // Preserve scroll when resizing
      const savedScrollTop = textarea.scrollTop
      const savedScrollLeft = textarea.scrollLeft
      syncHeights()
      // Restore scroll after resize (in case syncHeights didn't preserve it)
      if (textarea.scrollTop !== savedScrollTop || textarea.scrollLeft !== savedScrollLeft) {
        textarea.scrollTop = savedScrollTop
        textarea.scrollLeft = savedScrollLeft
      }
    })
    resizeObserver.observe(textarea)
    
    // Also sync heights periodically to catch any changes (less frequently)
    const heightSyncInterval = setInterval(() => {
      if (textarea && pre && Math.abs(pre.clientHeight - textarea.clientHeight) > 0.1) {
        syncHeights()
      }
    }, 500) // Check every 500ms instead of 100ms

    // Sync line numbers AND pre element with textarea scroll
    // Line numbers should scroll with content, not independently
    const handleScroll = () => {
      if (!textarea) return
      
      const scrollTop = textarea.scrollTop
      const scrollLeft = textarea.scrollLeft
      
      // Sync line numbers - use transform to move content since container has overflow: hidden
      // This prevents independent scrolling while keeping visual sync
      if (lineNumbers) {
        const lineNumbersContent = lineNumbers.querySelector('.code-editor-line-numbers-content') as HTMLElement
        if (lineNumbersContent) {
          // Move line numbers content to match textarea scroll position
          // The container has padding-top: 12px which matches editor padding, so transform aligns correctly
          lineNumbersContent.style.transform = `translateY(-${scrollTop}px)`
        }
      }
      
      // Sync pre element scroll position - MUST match exactly
      // Check if heights match and sync directly, otherwise adjust
      if (pre) {
        const clientHeightDiff = pre.clientHeight - textarea.clientHeight
        let finalScrollTop: number
        
        if (Math.abs(clientHeightDiff) < 1) {
          // Heights match - sync directly
          finalScrollTop = scrollTop
        } else {
          // Heights don't match - adjust
          const adjustedScrollTop = Math.max(0, scrollTop - clientHeightDiff)
          const maxPreScrollTop = pre.scrollHeight - pre.clientHeight
          finalScrollTop = Math.min(adjustedScrollTop, maxPreScrollTop)
        }
        
        // Force immediate sync
        pre.scrollTop = finalScrollTop
        pre.scrollLeft = scrollLeft
      }
    }
    
    // No continuous sync needed - the scroll event handler is sufficient
    // Since heights are now matched, the scroll handler will keep them in sync
    
    // Debug cursor position after scroll
    const handleSelectionChange = () => {
      if (textarea && pre) {
      }
    }
    
    // Monitor selection changes
    document.addEventListener('selectionchange', handleSelectionChange)
    textarea.addEventListener('click', handleSelectionChange)
    textarea.addEventListener('keyup', handleSelectionChange)
    textarea.addEventListener('focus', handleSelectionChange)

    textarea.addEventListener('scroll', handleScroll, { passive: true })
    
    
    return () => {
      textarea.removeEventListener('scroll', handleScroll)
      resizeObserver.disconnect()
      clearInterval(heightSyncInterval)
    }
    // Don't depend on localCode - preserve scroll position during editing
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []) // Only run once when component mounts

  // Sync local code changes back to frame
  const handleCodeChange = (newCode: string) => {
    setLocalCode(newCode)
    if (selectedFrame) {
      onCodeChange(selectedFrame.id, newCode)
    }
  }

  // Handle Tab key to insert spaces (Python standard: 4 spaces)
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Tab') {
      e.preventDefault()
      const target = e.currentTarget as HTMLTextAreaElement
      const start = target.selectionStart
      const end = target.selectionEnd
      const value = localCode
      
      // If there's a selection, indent/unindent the selected lines
      if (start !== end) {
        const lines = value.split('\n')
        const startLine = value.substring(0, start).split('\n').length - 1
        const endLine = value.substring(0, end).split('\n').length - 1
        
        if (e.shiftKey) {
          // Shift+Tab: Unindent (remove 4 spaces or 1 tab)
          for (let i = startLine; i <= endLine; i++) {
            if (lines[i].startsWith('    ')) {
              lines[i] = lines[i].substring(4)
            } else if (lines[i].startsWith('\t')) {
              lines[i] = lines[i].substring(1)
            }
          }
        } else {
          // Tab: Indent (add 4 spaces)
          for (let i = startLine; i <= endLine; i++) {
            lines[i] = '    ' + lines[i]
          }
        }
        
        const newValue = lines.join('\n')
        const newStart = start + (e.shiftKey ? -4 : 4)
        const newEnd = end + (endLine - startLine + 1) * (e.shiftKey ? -4 : 4)
        
        handleCodeChange(newValue)
        
        // Restore selection after state update
        setTimeout(() => {
          target.setSelectionRange(newStart, newEnd)
        }, 0)
      } else {
        // No selection: insert 4 spaces at cursor
        const newValue = value.substring(0, start) + '    ' + value.substring(end)
        handleCodeChange(newValue)
        
        // Move cursor after inserted spaces
        setTimeout(() => {
          target.setSelectionRange(start + 4, start + 4)
        }, 0)
      }
    }
  }

  const handleRunWithCode = async (codeToExecute: string) => {
    if (!selectedFrame || !isReady) {
      return
    }

    setIsRunning(true)
    setShowLoading(true)
    // Don't clear previous local execution result here - let errors persist until we know the new result
    // Only clear success messages
    if (localExecutionResult?.success) {
      setLocalExecutionResult(null)
    }
    
    // Minimum display time for loading indicator to prevent blinking
    const loadingStartTime = Date.now()
    const minLoadingTime = 300 // milliseconds

    // Collect vectors and functions created during execution
    // Don't clear first - keep old ones visible for smooth transition
    const newVectors: Vector[] = []
    const newFunctions: FunctionPlot[] = []

    // Generate unique IDs for vectors and functions
    const generateId = (prefix: string) => `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`

    try {
      // Calculate pixels per unit for screen-resolution-aware sampling
      const estimatedCanvasWidth = typeof window !== 'undefined' ? window.innerWidth : 1920
      const estimatedCanvasHeight = typeof window !== 'undefined' ? window.innerHeight : 1080
      // Use a default zoom estimate if viewport not available
      const estimatedZoom = 50 // Default zoom
      const pixelsPerUnit = estimatedZoom * (estimatedCanvasWidth / 1000)
      
      const result = await executeCode(
        codeToExecute,
        selectedFrame.id,
        // onVectorCreated callback
        (vector) => {
          newVectors.push({
            ...vector,
            id: generateId('vec'),
          })
        },
        // onFunctionCreated callback
        (func) => {
          newFunctions.push({
            ...func,
            id: generateId('func'),
          })
        },
        estimatedCanvasWidth,
        estimatedCanvasHeight,
        pixelsPerUnit
      )
      
      if (result.success) {
        setLocalExecutionResult({ success: true })
        
        // Atomically replace old vectors/functions with new ones
        // This keeps old ones visible until new ones are ready, eliminating blinking
        flushSync(() => {
          if (onVectorsUpdate) {
            onVectorsUpdate(selectedFrame.id, newVectors, true)
          }
          if (onFunctionsUpdate) {
            onFunctionsUpdate(selectedFrame.id, newFunctions, true)
          }
        })
        
        if (onCodeRun) {
          onCodeRun(selectedFrame.id, codeToExecute)
        }
      } else {
        // On error, set error result
        const errorMessage = result.error?.message || 
                            (typeof result.error === 'string' ? result.error : result.error?.toString()) || 
                            'Unknown error occurred'
        const errorResult = {
          success: false as const,
          error: errorMessage,
        }
        // Use flushSync to ensure error state is set immediately and persists
        flushSync(() => {
          setLocalExecutionResult(errorResult)
        })
        
        // On error, clear vectors/functions to show that execution failed
        flushSync(() => {
          if (onVectorsClear) {
            onVectorsClear(selectedFrame.id)
          }
          if (onFunctionsClear) {
            onFunctionsClear(selectedFrame.id)
          }
        })
      }
    } catch (error: any) {
      const errorMessage = error?.message || error?.toString() || 'Execution failed'
      const errorResult = {
        success: false as const,
        error: errorMessage,
      }
      // Use flushSync to ensure error state is set immediately and persists
      flushSync(() => {
        setLocalExecutionResult(errorResult)
      })
    } finally {
      setIsRunning(false)
      
      // Ensure loading indicator shows for minimum time
      const elapsed = Date.now() - loadingStartTime
      const remaining = Math.max(0, minLoadingTime - elapsed)
      if (remaining > 0) {
        setTimeout(() => {
          setShowLoading(false)
        }, remaining)
      } else {
        // Use a small delay even if we've exceeded min time to prevent flicker
        setTimeout(() => {
          setShowLoading(false)
        }, 50)
      }
    }
  }

  const handleRun = async () => {
    await handleRunWithCode(localCode)
  }

  if (!selectedFrame) {
    return null
  }

  return (
    <div className="h-full p-4 flex flex-col min-h-0 overflow-hidden">
      {!isReady && (
        <div className="mb-4 p-2 bg-warning/20 border border-warning/50 rounded text-sm text-warning">
          Pyodide is loading... (this may take a few seconds)
        </div>
      )}

      <div className="flex-1 flex flex-col min-h-0 overflow-hidden">
        <label className="block text-sm font-medium text-text-secondary mb-2 flex-shrink-0">
          Python Code
        </label>
        <div 
          ref={editorRef}
          className="flex-1 relative border border-border rounded bg-bg-primary flex" 
          style={{ minHeight: 0, overflow: 'hidden' }}
        >
          {/* Line numbers */}
          <div 
            ref={lineNumbersRef}
            className="code-editor-line-numbers flex-shrink-0"
            style={{ overflow: 'hidden' }}
          >
            <div className="code-editor-line-numbers-content">
              {localCode.split('\n').map((_, index) => (
                <div key={index} className="code-editor-line-number">
                  {index + 1}
                </div>
              ))}
            </div>
          </div>
          <div className="flex-1 relative" style={{ minHeight: 0, overflow: 'hidden' }}>
            <Editor
              value={localCode}
              onValueChange={handleCodeChange}
              onKeyDown={handleKeyDown}
              highlight={(code) => highlight(code, languages.python, 'python')}
              padding={12}
              style={{
                fontFamily: '"Fira Code", "Fira Mono", "Consolas", "Monaco", "Courier New", monospace',
                fontSize: 14,
                lineHeight: 1.5,
                outline: 'none',
                width: '100%',
                height: '100%',
                backgroundColor: '#0f172a',
                display: 'block',
              }}
              textareaClassName="code-editor-textarea"
              preClassName="code-editor-pre"
              placeholder={DEFAULT_CODE}
              tabSize={4}
              insertSpaces={true}
            />
          </div>
        </div>
      </div>

      {/* Status messages - below code editor, above Run button */}
      {/* Loading indicator during execution */}
      {showLoading && (
        <div className="mt-4 mb-2 p-3 bg-primary/10 border border-primary/30 rounded-lg flex items-center gap-3">
          <div className="w-4 h-4 border-2 border-primary border-t-transparent rounded-full animate-spin"></div>
          <span className="text-sm text-primary font-medium">Executing Python code...</span>
        </div>
      )}
      
      {/* Execution result messages - ONLY show manual execution errors, not auto-execution errors */}
      {/* Auto-execution errors are shown via badge indicator on the tab */}
      {localExecutionResult && !localExecutionResult.success && (
        <div className="mt-4 mb-2 p-3 rounded-lg text-sm bg-error/20 border border-error/50 text-error">
          <div>
            <div className="font-medium mb-2 flex items-center gap-2">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="w-4 h-4"
              >
                <circle cx="12" cy="12" r="10" />
                <line x1="12" y1="8" x2="12" y2="12" />
                <line x1="12" y1="16" x2="12.01" y2="16" />
              </svg>
              Execution Error
            </div>
            <div className="text-xs mt-1 font-mono bg-error/10 p-2 rounded border border-error/20 break-all whitespace-pre-wrap max-h-32 overflow-y-auto code-editor-error-message">
              {localExecutionResult.error || 'Unknown error occurred'}
            </div>
          </div>
        </div>
      )}
      
      {/* Success message - only show when not loading */}
      {executionResult && executionResult.success && !showLoading && !isRunning && !isExecuting && (
        <div className="mt-4 mb-2 p-3 rounded-lg text-sm bg-success/20 border border-success/50 text-success">
          <div className="flex items-center gap-2">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              className="w-4 h-4"
            >
              <path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" />
              <polyline points="22 4 12 14.01 9 11.01" />
            </svg>
            <span>Code executed successfully</span>
          </div>
        </div>
      )}

      <div className="mt-4 flex gap-2">
        <button
          onClick={handleRun}
          disabled={!isReady || isRunning || isExecuting}
          className={`flex-1 px-4 py-2 rounded-lg transition-colors text-sm font-medium ${
            !isReady || isRunning || isExecuting
              ? 'bg-bg-secondary text-text-secondary cursor-not-allowed'
              : 'bg-primary text-white hover:bg-blue-600'
          }`}
        >
          {isRunning || isExecuting ? 'Running...' : 'Run'}
        </button>
      </div>
    </div>
  )
}

export default memo(CodePanel)

