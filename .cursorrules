# YuDiMath Project Rules

## General Principles
- Write clean, maintainable, and well-documented code
- Follow consistent naming conventions
- Use TypeScript for type safety when possible
- Prioritize accessibility and user experience
- Write meaningful commit messages
- **PRIORITY: Code Modularity** - Prefer many small, focused files over few large all-in-one files
  - Maximum file size: ~300-500 lines (soft limit - refactor if significantly exceeded)
  - Break down large files into smaller, focused modules
  - Each file should have a single, clear responsibility
  - Extract reusable logic into separate utility files
  - Split large components into smaller sub-components
  - Keep functions/classes focused and cohesive
- **PRIORITY: Code Reuse** - Use existing utility functions instead of reinventing the wheel
  - **ALWAYS check `src/utils/` first** before implementing new functionality
  - Search for existing functions that might already solve the problem
  - If a function exists but needs modification, **extend or amend it** rather than creating a duplicate
  - If a function is close but not quite right, consider:
    - Adding optional parameters to make it more flexible
    - Creating a wrapper function that uses the existing one
    - Refactoring the existing function to be more general
  - Only create new utility functions when no existing solution can be adapted
  - Document why a new function was created if similar functionality exists

## ReactJS Rules

### Component Structure
- Use functional components with hooks (avoid class components)
- Keep components small and focused on a single responsibility
- Extract reusable logic into custom hooks
- Use React.memo() for expensive components that re-render frequently
- Prefer composition over inheritance

### State Management
- Use useState for local component state
- Use useReducer for complex state logic
- Consider Context API for shared state that doesn't need global state management
- Use proper state management library (Redux, Zustand, etc.) only when necessary

### Code Style
- Use ES6+ features (arrow functions, destructuring, template literals)
- Use meaningful variable and function names
- Extract magic numbers and strings into constants
- Use PropTypes or TypeScript for prop validation
- Follow React naming conventions: PascalCase for components, camelCase for functions/variables

### Performance
- Avoid creating functions/objects inside render methods
- Use useMemo and useCallback appropriately (don't overuse)
- Implement code splitting with React.lazy() for large components
- Optimize images and assets

### File Organization
- One component per file
- Co-locate related files (component, styles, tests) in the same directory
- Use index.js for clean imports
- Group by feature, not by file type
- **File Size Guidelines**:
  - Target: 200-400 lines per file (ideal)
  - Maximum: ~500 lines (hard limit - must refactor if exceeded)
  - If a file exceeds 300 lines, consider splitting it:
    - Extract utility functions to separate files
    - Split large components into smaller sub-components
    - Move complex logic to custom hooks
    - Separate types/interfaces into dedicated files
    - Extract constants and configuration to separate files
- **Modularity Priority**: Always prefer creating new small files over adding to existing large files

## Docker Rules

### Dockerfile Best Practices
- Use specific version tags, not 'latest'
- Use multi-stage builds to reduce image size
- Order Dockerfile instructions from least to most frequently changing
- Use .dockerignore to exclude unnecessary files
- Run as non-root user when possible
- Combine RUN commands to reduce layers
- Use COPY instead of ADD unless you need URL extraction

### Container Guidelines
- Keep containers stateless when possible
- Use environment variables for configuration
- Don't store secrets in images
- Expose only necessary ports
- Use health checks for long-running services

### Docker Compose
- Use docker-compose.yml for local development
- Define services with clear names
- Use volumes for development hot-reloading
- Set up proper networking between services
- Use environment files (.env) for configuration

## npm Rules

### Package Management
- Use exact versions in package.json for production dependencies (or use package-lock.json)
- Keep dependencies up to date and audit regularly
- Remove unused dependencies
- Use npm ci for CI/CD pipelines instead of npm install
- Document why each dependency is needed

### Scripts
- Use meaningful script names in package.json
- Group related scripts together
- Use npm-run-all for parallel/concurrent scripts
- Document scripts in README

### Security
- Run `npm audit` regularly
- Fix security vulnerabilities promptly
- Don't commit node_modules to version control
- Use .npmrc for project-specific npm configuration

### Version Management
- Follow semantic versioning (semver)
- Use npm version commands for version bumps
- Tag releases appropriately in git

## PyScript Rules

### Integration
- Load PyScript from CDN or local build
- Use proper HTML structure with py-script tags
- Keep Python code in separate .py files when possible
- Use py-config for configuration

### Code Organization
- Write Python code following PEP 8 style guide
- Use type hints where appropriate
- Keep Python scripts modular and reusable
- Handle errors gracefully with try-except blocks

### Performance
- Minimize Python code execution in the browser
- Use async/await for long-running operations
- Cache results when appropriate
- Avoid blocking the main thread

### Interoperability
- Use proper data exchange between JavaScript and Python
- Use PyScript's built-in methods for DOM manipulation
- Leverage Python's strengths (data processing, calculations)
- Use JavaScript for UI interactions and DOM manipulation

## File Structure
```
project-root/
├── src/
│   ├── components/
│   ├── hooks/
│   ├── utils/
│   ├── styles/
│   └── assets/
├── public/
├── docker/
│   ├── Dockerfile
│   └── docker-compose.yml
├── scripts/
│   └── *.py (PyScript files)
├── package.json
├── .dockerignore
├── .gitignore
└── README.md
```

## Git Workflow

### Commit Timing Rules
**CRITICAL**: Commits should ONLY be made in the following situations:

1. **When a step is fully completed**:
   - All implementation is done
   - All tests pass
   - Feature is verified in browser
   - Step is ready to be marked complete

2. **When a bug is fixed AND developer explicitly confirms**:
   - Bug is fully resolved
   - Developer explicitly states: "the bug is fixed and it is time to create a commit"
   - Do NOT commit during debugging or intermediate fixes

**DO NOT commit:**
- During active debugging or troubleshooting
- For intermediate changes that are not yet complete
- Automatically without explicit developer confirmation
- When tests are failing or features are incomplete

### Commit Message Guidelines
- Use meaningful commit messages following conventional commits
- Create feature branches for new features
- Keep commits atomic and focused
- Review code before merging

## Testing
- Write unit tests for utility functions
- Write component tests for React components
- Test critical user flows
- Maintain good test coverage

## Debugging and Troubleshooting
- **Use debug logs when a problem persists after two attempts**
  - If a fix doesn't work after two attempts, add strategic debug logging
  - Log key variables, function inputs/outputs, and state changes
  - Use descriptive log messages that identify the context (function name, component, etc.)
  - Log before and after critical operations to track state transitions
  - Use `console.log`, `console.debug`, or `console.error` as appropriate
  - Consider using conditional logging based on environment (e.g., `if (process.env.NODE_ENV === 'development')`)
- **Remove debug logs before committing**
  - All debug logs must be removed before final commits
  - Debug logs are temporary tools for investigation, not permanent code
  - Use the Code Review Checklist to verify no debug code remains
- **Debugging best practices**:
  - Start with understanding the expected behavior vs. actual behavior
  - Check browser console for errors and warnings
  - Use React DevTools for component state inspection
  - Use browser DevTools for network requests and performance
  - Add breakpoints in critical code paths if needed
  - Document findings and root cause analysis

## Documentation
- Document complex logic and algorithms
- Keep README.md updated
- Document API endpoints and data structures
- Include setup and deployment instructions

## Code Review Checklist
- [ ] Code follows project style guidelines
- [ ] No console.logs or debug code left in
- [ ] Error handling is implemented
- [ ] Accessibility considerations addressed
- [ ] Performance implications considered
- [ ] Security best practices followed
- [ ] Tests pass and coverage is adequate
